from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import json
import time

class UrbanRoutesPage:
    FROM_FIELD = (By.XPATH, "//input[@id='from']")
    TO_FIELD = (By.XPATH, "//input[@id='to']")
    REQUEST_TAXI_BUTTON = (By.CLASS_NAME, "button.round")
    COMFORT_OPTION = (By.XPATH, "//div[contains(text(), 'Comfort')]")
    COMFORT_CATEGORY_BUTTON = (By.XPATH, "//div[contains(@class, 'tcard') and .//div[normalize-space()='Comfort']]")
    PHONE_NUMBER_BUTTON = (By.XPATH, "//div[contains(text(), 'Phone number')]")
    PHONE_LABEL = (By.CSS_SELECTOR, "label[for='phone']")  # La etiqueta que est√° encima del bot√≥n de tel√©fono
    PHONE_INPUT = (By.ID, "phone")
    NEXT_BUTTON = (By.CSS_SELECTOR, "form button.button.full")
    SMS_CODE_INPUT = (By.ID, "code")
    CONFIRM_BUTTON = (By.XPATH, "//button[@class='button full' and @type='submit' and contains(text(), 'Confirm')]")
    RESEND_CODE_BUTTON = (By.XPATH, "//button[contains(text(), 'Vuelve a enviar el c√≥digo')]")

    # Localizador para el bot√≥n M√©todo de pago
    PAYMENT_METHOD_BUTTON = (By.XPATH, "//div[@class='pp-button filled']")  

    # Localizador para Agregar tarjeta
    ADD_CARD_BUTTON = (By.XPATH, "//div[@class='pp-title' and text()='Add a card']")
    
    # Localizadores para el campo N√∫mero de tarjeta
    CARD_NUMBER_INPUT = (By.ID, "number")
    
    CARD_CODE_INPUT = (By.ID, "code")
    COMMENT_INPUT = (By.ID, "comment")
    BLANKETS_SLIDER = (By.CLASS_NAME, "slider")
    ICE_CREAM_PLUS_BUTTON = (By.CLASS_NAME, "counter-plus")
    ORDER_TAXI_BUTTON_FINAL = (By.CLASS_NAME, "smart-button-main")
    BENDER_IMAGE = (By.XPATH, "//img[@alt='close']")

    def __init__(self, driver):
        self.driver = driver
        self.wait = WebDriverWait(driver, 15)

    # def debug_add_card_elements(self):
    #     """M√©todo temporal para debugging - muestra elementos con 'tarjeta' o 'card'"""
    #     import time
    #     time.sleep(2)
        
    #     # Buscar por clase pp-title
    #     titles = self.driver.find_elements(By.CLASS_NAME, "pp-title")
    #     print(f"\nüîç Elementos con clase 'pp-title': {len(titles)}")
    #     for i, title in enumerate(titles):
    #         try:
    #             text = title.text
    #             classes = title.get_attribute("class")
    #             is_displayed = title.is_displayed()
    #             print(f"\nElemento {i+1}:")
    #             print(f"  - Texto: '{text}'")
    #             print(f"  - Clases: '{classes}'")
    #             print(f"  - Visible: {is_displayed}")
    #         except Exception as e:
    #             print(f"  - Error: {e}")
        
    #     # Buscar todos los divs visibles
    #     divs = self.driver.find_elements(By.TAG_NAME, "div")
    #     print(f"\nüîç Buscando divs con 'tarjeta' o 'card' en el texto...")
    #     for div in divs:
    #         try:
    #             text = div.text
    #             if 'tarjeta' in text.lower() or 'card' in text.lower():
    #                 classes = div.get_attribute("class")
    #                 is_displayed = div.is_displayed()
    #                 if is_displayed:
    #                     print(f"\n  - Texto: '{text}'")
    #                     print(f"  - Clases: '{classes}'")
    #         except Exception:
    #             pass
    
    # M√©todo para abrir la p√°gina y espera que cargue completamente     
    def get_page(self, url, timeout=20): 
        self.driver.get(url)
        try:
            # Esperar que aparezca el logo-disclaimer con el nombre PLATFORM
            WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((By.CLASS_NAME, "logo-disclaimer"))
            )
            print("‚úÖ P√°gina cargada correctamente")
        except Exception as e:
            print(f"‚ö†Ô∏è Error esperando 'logo-disclaimer': {e}")
            print(f"üìÑ T√≠tulo despu√©s de espera: '{self.driver.title}'")


    # M√©todo para establecer la direcci√≥n de origen
    def set_from_address(self, address):
        from_field = self.wait.until(EC.presence_of_element_located(self.FROM_FIELD))
        from_field.clear()
        from_field.send_keys(address)


    # M√©todo para establecer la direcci√≥n de destino
    def set_to_address(self, address):
        to_field = self.wait.until(EC.presence_of_element_located(self.TO_FIELD))
        to_field.clear()
        to_field.send_keys(address)


    # M√©todo para hacer clic en el bot√≥n Pedir un taxi
    def click_request_taxi(self):
        button = self.wait.until(EC.element_to_be_clickable(self.REQUEST_TAXI_BUTTON))
        button.click()


    # M√©todo para seleccionar la categor√≠a Comfort
    def select_comfort_category(self):
        # Esperar a que el panel de tarifas aparezca (espera al primer tcard)
        self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, "tcard")))
        # Hacer clic en Comfort
        comfort = self.wait.until(EC.element_to_be_clickable(self.COMFORT_CATEGORY_BUTTON))
        comfort.click()


    # M√©todo para obtener el elemento de la categor√≠a Comfort        
    def get_comfort_element(self):
        # Obtener el elemento de la categor√≠a Comfort
        return self.wait.until(EC.visibility_of_element_located(self.COMFORT_CATEGORY_BUTTON))


    # M√©todo para hacer clic en el campo de tel√©fono
    def click_phone_field(self):
        """Abre el modal de tel√©fono y activa el campo"""
        # Hacer clic en el div que abre el modal
        phone_button = self.wait.until(
            EC.element_to_be_clickable((By.XPATH, "//div[contains(text(), 'Phone number')]"))
        )
        phone_button.click()
        print("‚úÖ Modal abierto y campo de tel√©fono listo")
        
        # Esperar que el input sea visible (el modal ya lo activa)
        self.wait.until(EC.visibility_of_element_located((By.ID, "phone")))


    # M√©todo para ingresar el n√∫mero de tel√©fono        
    def enter_phone_number(self, phone):
        """Ingresa el n√∫mero de tel√©fono en el campo de entrada"""
        phone_input = self.wait.until(EC.presence_of_element_located(self.PHONE_INPUT))
        phone_input.clear()
        phone_input.send_keys(phone)

    
    # M√©todo para hacer clic en el bot√≥n Siguiente
    def click_next_button(self):
        self.wait.until(EC.element_to_be_clickable(self.NEXT_BUTTON)).click()


    # M√©todo para ingresar el c√≥digo de verificaci√≥n
    def enter_sms_code(self, code):
        input_field = self.wait.until(EC.visibility_of_element_located(self.SMS_CODE_INPUT))
        input_field.clear()
        input_field.send_keys(code)
        
        # Dispara eventos manualmente si la app lo requiere
        self.driver.execute_script("arguments[0].dispatchEvent(new Event('input', { bubbles: true }));", input_field)
        self.driver.execute_script("arguments[0].dispatchEvent(new Event('change', { bubbles: true }));", input_field)
    
        print(f"‚úÖ C√≥digo de SMS '{code}' ingresado.")


    # M√©todo para hacer clic en Confirmar
    def click_confirm_button(self):
        from selenium.webdriver.support.ui import WebDriverWait
        
        # El bot√≥n ya est√° habilitado, solo necesitamos encontrarlo y hacer clic
        try:
            button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//button[text()='Confirm']"))
            )
            button.click()
            print("‚úÖ Bot√≥n 'Confirm' clickeado.")
        except Exception as e:
            print(f"‚ö†Ô∏è Error al hacer clic en 'Confirm': {e}")
            # Intentar con JavaScript como respaldo
            button = self.driver.find_element(By.XPATH, "//button[text()='Confirm']")
            self.driver.execute_script("arguments[0].click();", button)
            print("‚úÖ Bot√≥n 'Confirm' clickeado con JavaScript.")


    # M√©todo para esperar que el modal est√© visible
    def wait_for_sms_modal(self):
        self.wait.until(EC.visibility_of_element_located(self.SMS_CODE_INPUT))
        print("‚úÖ Modal de SMS visible.")
        
    
    # M√©todo para interceptar la respuesta de red y obtener el c√≥digo SMS
    def get_sms_code_from_network(self, phone_number):
        """
        Intercepta la respuesta de red que contiene el c√≥digo SMS.
        Busca una solicitud GET que contenga el n√∫mero de tel√©fono y devuelva un JSON con "code".
        """
        print("üîç Buscando c√≥digo SMS en la red...")
        
        # Espera para asegurar que la solicitud se haya completado
        time.sleep(3)  # 

        logs = self.driver.get_log("performance")
        
        for log in logs:
            try:
                message = json.loads(log["message"])
                method = message.get("message", {}).get("method")
                params = message.get("message", {}).get("params", {})
                
                if method == "Network.responseReceived":
                    # Verifica que 'response' exista en params
                    if "response" not in params:
                        continue
                    
                    response = params["response"]
                    url = response.get("url", "")
                    
                    # Normaliza el n√∫mero para coincidir con la URL (puede estar codificado)
                    normalized_phone = phone_number.replace("+", "%2B")  # Codificaci√≥n URL del '+'
                    
                    if normalized_phone in url or phone_number in url:
                        request_id = params.get("requestId")
                        if not request_id:
                            continue
                        
                        try:
                            body = self.driver.execute_cdp_cmd("Network.getResponseBody", {"requestId": request_id})
                            data = json.loads(body["body"])
                            if "code" in data:
                                code = str(data["code"])
                                print(f"‚úÖ C√≥digo SMS capturado: {code}")
                                return code
                        except Exception as e:
                            print(f"‚ö†Ô∏è No se pudo extraer el cuerpo de la respuesta: {e}")
                            continue
            except Exception:
                # Ignorar logs malformados o no relevantes
                continue
        raise Exception("‚ùå No se encontr√≥ el c√≥digo SMS en las respuestas de red.")


    # M√©todo para hacer clic en el bot√≥n M√©todo de pago
    def click_payment_method_button(self):
        button = self.wait.until(
            EC.element_to_be_clickable(self.PAYMENT_METHOD_BUTTON)
        )
        button.click()
        print("‚úÖ Bot√≥n 'M√©todo de pago' clickeado.")
    
    
    # M√©todo para verificar si el bot√≥n M√©todo de pago est√° visible    
    def is_payment_method_button_visible(self):
        try:
            button = self.wait.until(
                EC.visibility_of_element_located(self.PAYMENT_METHOD_BUTTON)
            )
            is_visible = button.is_displayed()
            if is_visible:
                print("‚úÖ Bot√≥n 'M√©todo de pago' est√° visible.")
            return is_visible
        except Exception as e:
            print(f"‚ùå Bot√≥n 'M√©todo de pago' NO est√° visible: {e}")
            return False


    # M√©todo para hacer click en el bot√≥n Agregar tarjeta
    def click_add_card_button(self):
        """Hace clic en el bot√≥n 'Agregar tarjeta'"""
        button = self.wait.until(
            EC.element_to_be_clickable(self.ADD_CARD_BUTTON)
        )
        button.click()
        print("‚úÖ Bot√≥n 'Agregar tarjeta' clickeado.")


    # M√©todo para verificar que "Agregar tarjeta" est√© visible
    def is_add_card_button_visible(self):
        """Verifica que el bot√≥n 'Agregar tarjeta' est√© visible"""
        try:
            button = self.wait.until(
                EC.visibility_of_element_located(self.ADD_CARD_BUTTON)
            )
            is_visible = button.is_displayed()
            if is_visible:
                print("‚úÖ Bot√≥n 'Agregar tarjeta' est√° visible.")
            return is_visible
        except Exception as e:
            print(f"‚ùå Bot√≥n 'Agregar tarjeta' NO est√° visible: {e}")
            return False


    # M√©todo para ingresar el n√∫mero de tarjeta
    def enter_card_number(self, card_number):
        input_field = self.wait.until(
            EC.visibility_of_element_located(self.CARD_NUMBER_INPUT)
        )
        input_field.clear()
        input_field.send_keys(card_number)
        print(f"‚úÖ N√∫mero de tarjeta '{card_number}' ingresado.")


    # M√©todo para verificar el valor del campo n√∫mero de tarjeta
    def get_card_number_value(self):
        """Obtiene el valor del campo n√∫mero de tarjeta"""
        input_field = self.driver.find_element(*self.CARD_NUMBER_INPUT)
        value = input_field.get_attribute("value")
        print(f"üí≥ Valor del campo n√∫mero de tarjeta: '{value}'")
        return value


    def enter_card_code(self, code):
        card_code = self.wait.until(EC.presence_of_element_located(self.CARD_CODE_INPUT))
        card_code.clear()
        card_code.send_keys(code)

    def add_comment(self, comment):
        comment_input = self.wait.until(EC.presence_of_element_located(self.COMMENT_INPUT))
        comment_input.clear()
        comment_input.send_keys(comment)

    def activate_blankets(self):
        self.wait.until(EC.element_to_be_clickable(self.BLANKETS_SLIDER)).click()

    def add_ice_creams(self, quantity=2):
        plus_btn = self.wait.until(EC.element_to_be_clickable(self.ICE_CREAM_PLUS_BUTTON))
        for _ in range(quantity):
            plus_btn.click()

    def click_order_taxi_final(self):
        self.wait.until(EC.element_to_be_clickable(self.ORDER_TAXI_BUTTON_FINAL)).click()

    def wait_for_bender(self):
        return self.wait.until(EC.presence_of_element_located(self.BENDER_IMAGE))

    def is_from_address_set(self, expected_address):
        from_field = self.driver.find_element(*self.FROM_FIELD)
        return from_field.get_attribute("value") == expected_address

    def is_to_address_set(self, expected_address):
        to_field = self.driver.find_element(*self.TO_FIELD)
        return to_field.get_attribute("value") == expected_address